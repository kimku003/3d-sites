<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cube 3D Interactif</title>
    <style>
        /* Styles CSS pour s'assurer que la toile occupe tout l'écran et est centrée */
        body {
            margin: 0;
            overflow: hidden; /* Empêche les barres de défilement */
            background-color: #111; /* Fond sombre */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Pleine hauteur de la fenêtre */
            font-family: 'Inter', sans-serif; /* Police Inter */
        }
        canvas {
            display: block; /* Assure que le canvas est un élément bloc */
            width: 100%; /* S'adapte à la largeur du conteneur */
            height: 100%; /* S'adapte à la hauteur du conteneur */
        }
        #controls-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            background-color: rgba(0,0,0,0.5);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="controls-info">Faites glisser pour faire pivoter le cube</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Variables globales
        let scene, camera, renderer, cube;
        let isDragging = false;
        let previousMousePosition = {
            x: 0,
            y: 0
        };

        // Initialisation de la scène 3D
        function init() {
            // Création de la scène
            scene = new THREE.Scene();

            // Création et positionnement de la caméra
            // Le champ de vision (fov) est de 75 degrés.
            // L'aspect ratio est basé sur la largeur et la hauteur de la fenêtre.
            // Les plans de coupe near et far définissent la plage de rendu.
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5; // Positionne la caméra en retrait pour voir le cube

            // Création du moteur de rendu WebGL
            renderer = new THREE.WebGLRenderer({ antialias: true }); // Antialiasing pour des bords plus lisses
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Meilleure qualité sur les écrans haute résolution
            document.body.appendChild(renderer.domElement); // Ajoute le canevas au corps du document

            // Création de la géométrie du cube
            // BoxGeometry prend la largeur, la hauteur et la profondeur comme arguments.
            const geometry = new THREE.BoxGeometry(2, 2, 2); // Un cube de 2x2x2 unités

            // Création du matériau du cube
            // MeshPhongMaterial réagit à la lumière, permettant des reflets.
            const material = new THREE.MeshPhongMaterial({
                color: 0x0095DD, // Couleur bleue
                shininess: 100,  // Brillance du matériau
                specular: 0x111111 // Couleur des reflets spéculaires
            });

            // Création du maillage (mesh) du cube en combinant la géométrie et le matériau
            cube = new THREE.Mesh(geometry, material);
            scene.add(cube); // Ajoute le cube à la scène

            // Ajout de lumières
            // Lumière ambiante pour éclairer globalement la scène
            const ambientLight = new THREE.AmbientLight(0x404040); // Lumière grise douce
            scene.add(ambientLight);

            // Lumière directionnelle pour simuler une source de lumière distante (comme le soleil)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Lumière blanche
            directionalLight.position.set(5, 5, 5); // Position de la lumière
            directionalLight.castShadow = true; // Permet à la lumière de projeter des ombres (non configuré ici)
            scene.add(directionalLight);

            // Ajout d'une lumière ponctuelle pour des reflets plus vifs
            const pointLight = new THREE.PointLight(0xffffff, 0.5);
            pointLight.position.set(-5, -5, 5);
            scene.add(pointLight);


            // Gestion des événements pour l'interaction (souris et toucher)
            // Événements pour la souris (desktop)
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('mouseout', onMouseUp, false); // Arrête le glissement si la souris sort du canvas

            // Événements pour le toucher (mobile)
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);

            // Gestion du redimensionnement de la fenêtre
            window.addEventListener('resize', onWindowResize, false);
        }

        // Fonction appelée lors du redimensionnement de la fenêtre
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); // Met à jour la matrice de projection de la caméra
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Fonctions de gestion des événements de la souris
        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseMove(event) {
            if (!isDragging) return;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            // Rotation du cube en fonction du mouvement de la souris
            // La vitesse de rotation peut être ajustée en modifiant le multiplicateur (0.01 ici)
            cube.rotation.y += deltaX * 0.01;
            cube.rotation.x += deltaY * 0.01;

            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseUp() {
            isDragging = false;
        }

        // Fonctions de gestion des événements tactiles
        function onTouchStart(event) {
            if (event.touches.length === 1) { // Gère uniquement le toucher simple
                isDragging = true;
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }

        function onTouchMove(event) {
            if (!isDragging || event.touches.length !== 1) return;

            event.preventDefault(); // Empêche le défilement de la page sur mobile

            const deltaX = event.touches[0].clientX - previousMousePosition.x;
            const deltaY = event.touches[0].clientY - previousMousePosition.y;

            cube.rotation.y += deltaX * 0.01;
            cube.rotation.x += deltaY * 0.01;

            previousMousePosition.x = event.touches[0].clientX;
            previousMousePosition.y = event.touches[0].clientY;
        }

        function onTouchEnd() {
            isDragging = false;
        }

        // Boucle d'animation
        function animate() {
            requestAnimationFrame(animate); // Demande la prochaine frame d'animation

            // Si aucune interaction n'est en cours, on peut ajouter une rotation automatique lente
            if (!isDragging) {
                 cube.rotation.x += 0.001;
                 cube.rotation.y += 0.001;
            }

            renderer.render(scene, camera); // Rendu de la scène
        }

        // Démarrage de l'initialisation et de l'animation après le chargement de la fenêtre
        window.onload = function() {
            init();
            animate();
        };
    </script>
</body>
</html>

